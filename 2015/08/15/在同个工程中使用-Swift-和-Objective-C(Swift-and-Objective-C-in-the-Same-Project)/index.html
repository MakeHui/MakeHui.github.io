<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>在同个工程中使用 Swift 和 Objective-C(Swift and Objective-C in the Same Project) | MakeHui&#39;s 超平和バスターズはずっとなかよし</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 mix and match 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。">
<meta property="og:type" content="article">
<meta property="og:title" content="在同个工程中使用 Swift 和 Objective-C(Swift and Objective-C in the Same Project)">
<meta property="og:url" content="http://huyaohui.com/2015/08/15/在同个工程中使用-Swift-和-Objective-C(Swift-and-Objective-C-in-the-Same-Project)/index.html">
<meta property="og:site_name" content="MakeHui's 超平和バスターズはずっとなかよし">
<meta property="og:description" content="Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 mix and match 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。">
<meta property="og:image" content="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/DAG_2x.png?raw=true">
<meta property="og:image" content="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/bridgingheader_2x.png?raw=true">
<meta property="og:updated_time" content="2016-01-03T03:13:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="在同个工程中使用 Swift 和 Objective-C(Swift and Objective-C in the Same Project)">
<meta name="twitter:description" content="Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 mix and match 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。">
  
    <link rel="alternative" href="/atom.xml" title="MakeHui&#39;s 超平和バスターズはずっとなかよし" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">MakeHui</a></h1>
		</hgroup>

		
		<p class="header-subtitle">あの日見た花の名前を僕達はまだ知らない。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/iOS">iOS</a></li>
				        
							<li><a href="/Niconiconi">Niconiconi</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/MakeHui" title="github">github</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/Make_hui" title="twitter">twitter</a>
					        
								<a class="mail" target="_blank" href="/makehuir@gmail.com" title="mail">mail</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Branckets/" style="font-size: 12.86px;">Branckets</a> <a href="/tags/Brew/" style="font-size: 10px;">Brew</a> <a href="/tags/Build/" style="font-size: 10px;">Build</a> <a href="/tags/CLI/" style="font-size: 10px;">CLI</a> <a href="/tags/CentOS/" style="font-size: 10px;">CentOS</a> <a href="/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/tags/Config/" style="font-size: 10px;">Config</a> <a href="/tags/Cordova/" style="font-size: 12.86px;">Cordova</a> <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/GitHub/" style="font-size: 11.43px;">GitHub</a> <a href="/tags/GitHub-page/" style="font-size: 10px;">GitHub page</a> <a href="/tags/GitLab/" style="font-size: 10px;">GitLab</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/HTML5/" style="font-size: 15.71px;">HTML5</a> <a href="/tags/Hello-World/" style="font-size: 10px;">Hello World</a> <a href="/tags/Hexo/" style="font-size: 11.43px;">Hexo</a> <a href="/tags/HybridApp/" style="font-size: 12.86px;">HybridApp</a> <a href="/tags/Mac-OSX/" style="font-size: 10px;">Mac OSX</a> <a href="/tags/Note/" style="font-size: 18.57px;">Note</a> <a href="/tags/Plugin/" style="font-size: 14.29px;">Plugin</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/ShareSDK/" style="font-size: 11.43px;">ShareSDK</a> <a href="/tags/Storyboard/" style="font-size: 10px;">Storyboard</a> <a href="/tags/Swift/" style="font-size: 17.14px;">Swift</a> <a href="/tags/TextEditor/" style="font-size: 12.86px;">TextEditor</a> <a href="/tags/Think/" style="font-size: 11.43px;">Think</a> <a href="/tags/Web/" style="font-size: 14.29px;">Web</a> <a href="/tags/WebApp/" style="font-size: 10px;">WebApp</a> <a href="/tags/Xcode/" style="font-size: 11.43px;">Xcode</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iTerm/" style="font-size: 10px;">iTerm</a> <a href="/tags/sshpass/" style="font-size: 10px;">sshpass</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">热爱各种黑科技, 擅长服务器运维和数据库架构优化, 目前从事 Native App for iOS 的开发, 以及 Hybrid App for HTML5 的研究, 正在向着全栈工程师的不归路前进着.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">MakeHui</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/author.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">MakeHui</h1>
			</hgroup>
			
			<p class="header-subtitle">あの日見た花の名前を僕達はまだ知らない。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/iOS">iOS</a></li>
		        
					<li><a href="/Niconiconi">Niconiconi</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/MakeHui" title="github">github</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/Make_hui" title="twitter">twitter</a>
			        
						<a class="mail" target="_blank" href="/makehuir@gmail.com" title="mail">mail</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-在同个工程中使用-Swift-和-Objective-C(Swift-and-Objective-C-in-the-Same-Project)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/15/在同个工程中使用-Swift-和-Objective-C(Swift-and-Objective-C-in-the-Same-Project)/" class="article-date">
  	<time datetime="2015-08-15T01:39:26.000Z" itemprop="datePublished">2015-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      在同个工程中使用 Swift 和 Objective-C(Swift and Objective-C in the Same Project)
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS/">iOS</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 mix and match 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>
<a id="more"></a>
<blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="在同个工程中使用_Swift_和_Objective-C">在同个工程中使用 Swift 和 Objective-C</h1><p>本节包含内容：</p>
<ul>
<li><a href="#mix_and_match_overview">Mix and Match 概述（Mix and Match Overview）</a></li>
<li><a href="#importing_code_from_within_the_same_app_target">在同个应用的 target 中导入（Importing Code from Within the Same App Target）</a></li>
<li><a href="#importing_code_from_within_the_same_framework_target">在同个 Framework 的 target 中导入（Importing Code from Within the Same Framework Target）</a></li>
<li><a href="#importing_external_frameworks">导入外部 framework（Importing External Frameworks）</a></li>
<li><a href="#using_Swift_from_objective-c">在 Objective-C 中使用 Swift（Using Swift from Objective-C）</a></li>
<li><a href="#overriding_Swift_names_for_Objective">为 Objective-C 接口重写 Swift 名称</a></li>
<li><a href="#naming_your_product_module">Product 模块命名（Naming Your Product Module）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p><a name="mix_and_match_overview"></a></p>
<h2 id="Mix_and_Match_概述">Mix and Match 概述</h2><p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>
<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>
<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/DAG_2x.png?raw=true" alt="DAG_2x.png"></p>
<p><a name="importing_code_from_within_the_same_app_target"></a></p>
<h2 id="在同个应用的_target_中导入">在同个应用的 target 中导入</h2><p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>
<h3 id="将_Objective-C_导入_Swift">将 Objective-C 导入 Swift</h3><p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>
<p><img src="https://raw.githubusercontent.com/haolloyin/Welcome-to-Swift/translate/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/bridgingheader_2x.png?raw=true" alt="bridgingheader_2x.png"></p>
<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>。</p>
<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>
<h4 id="在同一_target_中将_Objective-C_代码导入到_Swift_中">在同一 target 中将 Objective-C 代码导入到 Swift 中</h4><ol>
<li>在 Objective-C 桥接头文件中，<code>import</code>任何你想暴露给 Swift 的头文件，例如：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"XYZCustomCell.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"XYZCustomView.h"</span></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"XYZCustomViewController.h"</span></span><br></pre></td></tr></table></figure>
<ol>
<li>确保在 <code>build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>
<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>
<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入到_Objective-C">将 Swift 导入到 Objective-C</h3><p>当你在将 Swift 代码导入到 Objective-C 中时，你依赖于 Xcode 生成的头文件来将这些文件暴漏给 Objective-C。这个自动生成的文件是一个 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。头文件名称以 product 模块名加 <code>-Swift.h</code> 来命名。（关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>）。</p>
<p>默认情况下，生成的头文件包含了标记有<code>public</code>修饰符的 Swift 声明接口。它还包含那些打上，如果您的应用程序的目标有一个Objective-C的桥接头内部修改。标有private修饰符声明不会出现在所生成的报头。私人声明没有接触到Objective-C的，除非它们被明确标有@IBAction，@IBOutlet，或@objc为好。如果您的应用程序的目标是编译测试启用，单元测试目标可以访问任何声明与内部修饰，仿佛他们与公众修饰符通过预先@testable的产品模块导入语句声明。</p>
<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>
<h4 id="在同一_target_中将_Swift_代码导入到_Objective-C_中">在同一 target 中将 Swift 代码导入到 Objective-C 中</h4><ul>
<li>在相同 target 的 Objective-C.m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> <span class="string">"ProductModuleName-Swift.h"</span></span><br></pre></td></tr></table></figure>
<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_code_from_within_the_same_framework_target"></a></p>
<h2 id="在同个_Framework_的_target_中导入">在同个 Framework 的 target 中导入</h2><p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>
<h3 id="将_Objective-C_导入_Swift-1">将 Objective-C 导入 Swift</h3><p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>
<h4 id="在同一_framework_中将_Objective-C_代码导入到_Swift_中">在同一 framework 中将 Objective-C 代码导入到 Swift 中</h4><p>确保将框架 target 的 <code>build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;<span class="type">XYZ</span>/<span class="type">XYZCustomCell</span>.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;<span class="type">XYZ</span>/<span class="type">XYZCustomView</span>.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;<span class="type">XYZ</span>/<span class="type">XYZCustomViewController</span>.h&gt;</span><br></pre></td></tr></table></figure>
<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入_Objective-C">将 Swift 导入 Objective-C</h3><p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>
<h4 id="在同一_framework_中将_Swift_代码导入到_Objective-C_中">在同一 framework 中将 Swift 代码导入到 Objective-C 中</h4><p>确保将框架 target 的 <code>build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OBJECTIVE-C</span></span><br><span class="line">#<span class="keyword">import</span> &lt;<span class="type">ProductName</span>/<span class="type">ProductModuleName</span>-<span class="type">Swift</span>.h&gt;</span><br></pre></td></tr></table></figure>
<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductName/ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_external_frameworks"></a></p>
<h2 id="导入外部_Framework">导入外部 Framework</h2><p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>
<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">FrameworkName</span></span><br></pre></td></tr></table></figure>
<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="type">FrameworkName</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架</td>
<td style="text-align:center">import FrameworkName</td>
<td style="text-align:center">@import FrameworkName;</td>
</tr>
</tbody>
</table>
<p><a name="using_Swift_from_objective-c"></a></p>
<h2 id="在_Objective-C_中使用_Swift">在 Objective-C 中使用 Swift</h2><p>当你将 Swift 代码导入 Objective-C 之后，便可用常规的 Objective-C 语法来使用 Swift 类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MySwiftClass</span> *<span class="type">SwiftObject</span> = [[<span class="type">MySwiftClass</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[<span class="type">SwiftObject</span> <span class="type">SwiftMethod</span>];</span><br></pre></td></tr></table></figure>
<p>Swift 的类或协议必须用 <code>@objc</code>属性来标记，以便在 Objective-C 中可访问。这个 属性告诉编译器这块 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@objc</code>。详见 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID53" target="_blank" rel="external">Swift Type Compatibility</a>。</p>
<p>你可以访问在 Swift 类或协议中使用用<code>@objc</code>属性标记的任何对象，只要该对象与 Objective-C 兼容。不包括以下 Swift 独有的特性：</p>
<ul>
<li><p>范型（Generics）</p>
</li>
<li><p>元组（Tuples）</p>
</li>
<li><p>Swift 中定义的枚举不包括<code>Int</code>原始值类型（Enumerations defined in Swift without Int raw value type）</p>
</li>
<li><p>Swift 中定义的结构体（Structures defined in Swift）   </p>
</li>
<li><p>Swift 中定义的顶层函数（Top-level functions defined in Swift）</p>
</li>
<li><p>Swift 中定义的全局变量（Global variables defined in Swift）</p>
</li>
<li><p>Swift 中定义的类型别名（Typealiases defined in Swift）</p>
</li>
<li><p>Swift风格可变参数（Swift-style variadics）</p>
</li>
<li><p>嵌套类型（Nested types）</p>
</li>
<li><p>柯里化函数（Curried functions）</p>
</li>
</ul>
<p>例如，使用范型类型作为参数，或者返回元组的方法将不能在 Objective-C 中使用。</p>
<blockquote>
<p>注意<br>你不能在 Objective-C 继承一个 Swift 类。</p>
</blockquote>
<h3 id="在_Objective-C_头文件中引用_Swift_类">在 Objective-C 头文件中引用 Swift 类</h3><p>这样前向声明 Swift 类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OBJECTIVE-C</span></span><br><span class="line"><span class="comment">// MyObjective-CClass.h</span></span><br><span class="line"></span><br><span class="line">@<span class="class"><span class="keyword">class</span> <span class="title">MySwiftClass</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title">interface</span> <span class="title">MyObjective</span>-<span class="title">CClass</span> : <span class="title">NSObject</span></span><br><span class="line">- (<span class="title">MySwiftClass</span> *)<span class="title">returnSwiftObject</span>;</span><br><span class="line">/* ... */</span><br><span class="line">@<span class="title">end</span></span></span><br></pre></td></tr></table></figure>
<p><a name="overriding_Swift_names_for_Objective-C_interfaces"></a></p>
<h2 id="为_Objective-C_接口重写_Swift_名称">为 Objective-C 接口重写 Swift 名称</h2><p>Swift 编译器自动的将 Objective-C 代码作为常规 Swift 代码导入。它将 Objective-C 的类工厂方法作为 Swift 构造器导入，以及将 Objective-C 的枚举类型名称截断处理。</p>
<p>在你的代码中也许存在不能够被自动处理的边界情况。如果你需要更改导入到 Swift 中的 Objective-C 方法，枚举，或者可选 set 值，你可以使用<code>NS_Swift_NAME</code>宏来自定义导入的声明。</p>
<h3 id="类工厂方法">类工厂方法</h3><p>如果 Swift 编译器无法识别类工厂方法，你可以使用<code>NS_Swift_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)recordWithRPM:(<span class="type">NSUInteger</span>)<span class="type">RPM</span> <span class="type">NS_Swift_NAME</span>(<span class="keyword">init</span>(<span class="type">RPM</span>:));</span><br></pre></td></tr></table></figure>
<p>如果 Swift 编译器错误的将一个方法识别为类工厂方法，你可以使用<code>NS_Swift_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id)recordWithQuality:(double)quality <span class="type">NS_Swift_NAME</span>(record(quality:));</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3><p>默认情况下，Swift 将枚举值的名称前缀做截断来导入枚举。如果要自定义枚举值的名称，你可以使用<code>NS_Swift_NAME</code>宏来传递 Swift 枚举值名称。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">ABCRecordSide</span>) &#123;</span><br><span class="line">  <span class="type">ABCRecordSideA</span>,</span><br><span class="line">  <span class="type">ABCRecordSideB</span> <span class="type">NS_Swift_NAME</span>(<span class="string">"FlipSide"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="naming_your_product_module"></a></p>
<h2 id="Product_模块命名">Product 模块命名</h2><p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>
<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突。</li>
<li>如果你使用了框架，确保在<code>Packaging</code>下的<code>Defines Module</code>编译设置被设置为 <code>Yes</code>。</li>
<li>如果你使用了 Objective-C 桥接头文件，确保 Swift 编译器中 Objective-C 桥接头文件的编译设置<code>Code Generation</code>有一个与项目相关的头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
<li>Xcode 使用你的工程模块名，而不是以<code>target</code>的名称来命名 Objective-C 桥接头文件以及为 Swift 代码 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID138" target="_blank" rel="external">Naming Your Product Module</a>。</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@objc</code> 标记。</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性转化成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID136" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</li>
<li>用<code>private</code>修饰符标记的 Swift 声明不会出现在自动生成的头文件中。私有声明不会暴漏给 Objective-C，除非它们被明确标记有<code>@IBAction</code>，<code>@IBOutlet</code>或者<code>@objc</code>等。</li>
<li>对于应用 targets 而言，如果有 Objective-C 桥接头文件时，被<code>internal</code>修饰符标记的声明会出现在自动产生的头文件中。</li>
<li>对于框架 targets 而言，只有被<code>public</code>修饰符标记的声明才会出现在自动生成的头文件中。你仍然可以在框架中的 Objective-C 部分使用被<code>internal</code>修饰符标记的 Swift 方法和属性，只要它们声明所在的类继承自 Objective-C 类。关于访问级别修饰符的更多信息，请查看<a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a>中的<a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41" target="_blank" rel="external">访问控制(Access Control)</a></li>
</ul>
<h2 id="参考资料">参考资料</h2><h3 id="转载">转载</h3><p><a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md" target="_blank" rel="external">在同个工程中使用 Swift 和 Objective-C</a></p>
<h3 id="官方资料">官方资料</h3><p><a href="https://developer.apple.com/library/prerelease/iOS/documentation/Swift/Conceptual/buildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Swift and Objective-C in the Same Project</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/08/15/iOS-Swift开发-常用库使用说明/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          iOS Swift开发 常用库使用说明
        
      </div>
    </a>
  
  
    <a href="/2015/08/14/iOS-Storyboard-布局警告相关说明/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iOS Storyboard 布局警告相关说明</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="在同个工程中使用-Swift-和-Objective-C(Swift-and-Objective-C-in-the-Same-Project)" data-title="在同个工程中使用 Swift 和 Objective-C(Swift and Objective-C in the Same Project)" data-url="http://huyaohui.com/2015/08/15/在同个工程中使用-Swift-和-Objective-C(Swift-and-Objective-C-in-the-Same-Project)/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"makehui"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 MakeHui
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>